0
00:00:01,510 --> 00:00:03,730
So now you have two options, and

1
00:00:03,730 --> 00:00:06,580
we are going to use the second options of using

2
00:00:06,580 --> 00:00:10,660
logistic regression with Softmax in this module.

3
00:00:10,660 --> 00:00:15,970
And we will continue to use Softmax as our preferred choice.

4
00:00:15,970 --> 00:00:17,050
And when you do that,

5
00:00:17,050 --> 00:00:22,418
keep in mind that you do not want to add any activation layer

6
00:00:22,418 --> 00:00:28,230
like we have omitted here and made it a pass through.

7
00:00:28,230 --> 00:00:30,350
You'll see that in your hands-on lab as well.

8
00:00:32,550 --> 00:00:37,370
Now that we have the output of our classify in the form of

9
00:00:37,370 --> 00:00:38,719
predictive probabilities.

10
00:00:39,780 --> 00:00:44,560
We can take this output here and

11
00:00:44,560 --> 00:00:50,480
compare it with the labels that we got for

12
00:00:50,480 --> 00:00:53,565
this particular digit which is the digit 3.

13
00:00:55,060 --> 00:00:57,320
And see how well we did.

14
00:00:57,320 --> 00:00:59,510
But how can we possibly do that?

15
00:00:59,510 --> 00:01:03,251
Because this is a number and

16
00:01:03,251 --> 00:01:07,811
this is a an array of ten numbers.

17
00:01:07,811 --> 00:01:13,370
With the fourth element indicating the digit 3.

18
00:01:16,050 --> 00:01:19,020
So here we would like to

19
00:01:19,020 --> 00:01:23,450
get to a notion of calculating differences between

20
00:01:25,070 --> 00:01:29,910
the labels that are provided by the training data set and

21
00:01:29,910 --> 00:01:33,890
compare it with our predicted values from the model.

22
00:01:35,970 --> 00:01:37,750
Let's tackle the model first.

23
00:01:37,750 --> 00:01:40,015
We take the image, we flatten it,

24
00:01:40,015 --> 00:01:42,054
we pass it through this model.

25
00:01:42,054 --> 00:01:45,833
The model learns the parameters ws and bs and

26
00:01:45,833 --> 00:01:49,830
generate the corresponding probabilities.

27
00:01:49,830 --> 00:01:52,870
You guys have completely mastered it.

28
00:01:55,060 --> 00:01:58,160
Now let's take the labels, figure out what we can do with.

29
00:01:59,350 --> 00:02:02,723
So for each image that you see here,

30
00:02:02,723 --> 00:02:08,797
there is a corresponding output that you would like to produce,

31
00:02:08,797 --> 00:02:12,522
which is, in this case, the digit 3.

32
00:02:16,004 --> 00:02:23,009
So one way to do it is something called one-hot encoding.

33
00:02:23,009 --> 00:02:30,320
It means that you will create an array of the length

34
00:02:30,320 --> 00:02:35,100
that mimics the number of unique labels in your data set.

35
00:02:35,100 --> 00:02:39,430
In our data set we have zero to nine digits, so

36
00:02:39,430 --> 00:02:45,080
there are 10 possible categories to which an image can be mapped.

37
00:02:46,190 --> 00:02:49,170
We create a container of length 10 here.

38
00:02:50,760 --> 00:02:53,750
That means there are 10 values possible.

39
00:02:53,750 --> 00:02:59,060
And in this case, for the image being the 100 digit of 3,

40
00:02:59,060 --> 00:03:03,830
we want to have the corresponding cell

41
00:03:03,830 --> 00:03:08,670
number to be indicative of

42
00:03:08,670 --> 00:03:11,580
the number being present in the hand with the digits.

43
00:03:11,580 --> 00:03:15,430
So in this case the fourth element which is 0, 1, 2, and

44
00:03:15,430 --> 00:03:21,160
3 would have the value of 1 shown here.

45
00:03:22,700 --> 00:03:27,349
And the rest of it are all 0s.

46
00:03:27,349 --> 00:03:32,926
Now what we do, is we will compare this labelled data,

47
00:03:32,926 --> 00:03:38,023
which we have transformed from the original digit

48
00:03:38,023 --> 00:03:43,980
3 to a one-hot encoding of a vector of length 10.

49
00:03:43,980 --> 00:03:48,370
And we can compare the difference between that and

50
00:03:48,370 --> 00:03:51,410
the probabilities that are predicted by our model.

51
00:03:53,570 --> 00:03:58,780
Again going back to high school maths you can do that

52
00:03:58,780 --> 00:04:03,400
by taking the element wise differences between

53
00:04:03,400 --> 00:04:08,790
these two arrays then some of the squares.

54
00:04:08,790 --> 00:04:10,720
This is called the squared error.

55
00:04:11,810 --> 00:04:14,100
This is one way of calculating the differences.

56
00:04:14,100 --> 00:04:18,220
However, there is a statistically more robust way of

57
00:04:18,220 --> 00:04:20,870
doing it which has better behavior.

58
00:04:20,870 --> 00:04:24,690
I won't go into the technical details of why, but

59
00:04:24,690 --> 00:04:29,110
suffice to say in cases where you are mapping an input

60
00:04:29,110 --> 00:04:33,740
to some categorical set of values, it is preferred that

61
00:04:33,740 --> 00:04:36,600
to use something called a cross entropy error.

62
00:04:38,870 --> 00:04:43,890
Again, it compares each individual values in these

63
00:04:43,890 --> 00:04:49,820
arrays or this is Yi Yj, and the corresponding probabilities,

64
00:04:51,050 --> 00:04:55,610
and some sub the contributions from these two values.

65
00:04:57,230 --> 00:05:02,250
When the values match or come closest, the values for

66
00:05:02,250 --> 00:05:03,580
this cell to that.

67
00:05:03,580 --> 00:05:06,680
And so on and so forth for the entire area is the closest.

68
00:05:06,680 --> 00:05:09,460
This value would have the lowest possible error.

69
00:05:10,870 --> 00:05:15,710
This is called the loss function.

70
00:05:15,710 --> 00:05:18,660
And we will refer to the loss function in the hands on

71
00:05:18,660 --> 00:05:19,730
tutorial, and

72
00:05:19,730 --> 00:05:22,890
in moving forward you will hear a lot about loss functions.

73
00:05:22,890 --> 00:05:24,690
So, when we refer to loss functions,

74
00:05:24,690 --> 00:05:28,260
it could be most of the cases cross entropy error,

75
00:05:28,260 --> 00:05:33,340
especially when the output is of categorical values.

76
00:05:33,340 --> 00:05:36,781
In other words categories, in this case, digits of 0 to 9,

77
00:05:36,781 --> 00:05:39,697
as opposed to continuous values which was the output

78
00:05:39,697 --> 00:05:40,843
of the solar panel.

