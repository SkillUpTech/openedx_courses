0
00:00:01,550 --> 00:00:04,500
So now you know what we are up to.

1
00:00:04,500 --> 00:00:08,830
We have a model and we want to learn it from the MS data.

2
00:00:08,830 --> 00:00:13,590
And this model has parameters of weights and biases represented

3
00:00:13,590 --> 00:00:18,400
by the matrix w, and bias b.

4
00:00:18,400 --> 00:00:20,140
So, let's dive right into it and

5
00:00:20,140 --> 00:00:24,140
figure out what are these values and how we can learn from there.

6
00:00:26,820 --> 00:00:30,760
First of all, we will flatten out the image and

7
00:00:30,760 --> 00:00:32,480
represent in the form of an array.

8
00:00:32,480 --> 00:00:35,657
You are already familiar with that, and

9
00:00:35,657 --> 00:00:40,620
the next thing is to figure out what these matrix elements are.

10
00:00:41,680 --> 00:00:46,500
So the first thing we do is for each of the input feature values

11
00:00:46,500 --> 00:00:51,308
here, we pair it up with the corresponding weight,

12
00:00:51,308 --> 00:00:55,490
single integer value.

13
00:00:55,490 --> 00:00:59,550
And we generate similar pairings for

14
00:00:59,550 --> 00:01:05,300
all the 784 pixels that we have, and

15
00:01:05,300 --> 00:01:11,945
these are going to be 784 values represented by these arrows.

16
00:01:13,670 --> 00:01:18,490
And this is indicated by a vector of weights,

17
00:01:18,490 --> 00:01:22,830
of length 784 over here.

18
00:01:23,930 --> 00:01:30,780
Now this one is going to be tuned for

19
00:01:30,780 --> 00:01:34,720
detecting the digit 0.

20
00:01:34,720 --> 00:01:39,688
Now, let's for now pretend that someone has given you

21
00:01:39,688 --> 00:01:43,577
a magical set of values for these weights.

22
00:01:43,577 --> 00:01:48,719
Such that when you multiply the weight values

23
00:01:48,719 --> 00:01:53,456
with their corresponding pixel values,

24
00:01:53,456 --> 00:01:59,677
if this image was 0, then the output of the this unit,

25
00:01:59,677 --> 00:02:04,548
which is represented by this dot product,

26
00:02:04,548 --> 00:02:08,910
is gonna be very high for the input 0.

27
00:02:08,910 --> 00:02:12,610
When that handwritten digit is 0, you'll get a very high

28
00:02:12,610 --> 00:02:16,490
value here, and at all other times it will be very, very low.

29
00:02:18,710 --> 00:02:23,420
So this is my classifier to detect the digit 0.

30
00:02:23,420 --> 00:02:28,425
I'm gonna repeat this process for digit 1,

31
00:02:28,425 --> 00:02:35,405
and corresponding to that digit I have another set of weights,

32
00:02:35,405 --> 00:02:41,478
784 of those, predicting the values for digit 1.

33
00:02:44,106 --> 00:02:50,399
Similarly, we will repeat this process

34
00:02:50,399 --> 00:02:56,135
until we have one classifier each for

35
00:02:56,135 --> 00:03:01,315
the digit 0 to 9, in that case we

36
00:03:01,315 --> 00:03:06,700
have a set of 10 weight vectors.

37
00:03:06,700 --> 00:03:10,180
Each of them 784, corresponding to the size of the input vector

38
00:03:10,180 --> 00:03:15,710
here, and this starts to take the shape of a matrix.

39
00:03:17,180 --> 00:03:22,080
So, instead of doing a dot product

40
00:03:22,080 --> 00:03:27,160
with respect to the input for a digit 0 here, and then for

41
00:03:27,160 --> 00:03:30,915
digit one, 1, then so and so forth all the way to digit 9.

42
00:03:32,890 --> 00:03:36,490
Modern day computers can do it all in one go,

43
00:03:36,490 --> 00:03:41,480
very efficiently, using a matrix multiplication operation,

44
00:03:41,480 --> 00:03:43,250
which is indicated here.

45
00:03:43,250 --> 00:03:47,990
w is a matrix, and you have the corresponding vector.

46
00:03:47,990 --> 00:03:52,516
Now if you're wondering why that T shows up,

47
00:03:52,516 --> 00:03:56,922
there's a bit of math involved, which is,

48
00:03:56,922 --> 00:04:03,966
because you have 10 x 784 as the dimensions of the weight matrix.

49
00:04:03,966 --> 00:04:08,809
And you want the vector to be 784 x 1,

50
00:04:08,809 --> 00:04:15,372
which is mathematically represented as x transpose.

51
00:04:17,319 --> 00:04:20,890
Now once you've done that, we are missing something here.

52
00:04:20,890 --> 00:04:23,275
Take a moment, think about it, what are we missing?

53
00:04:26,170 --> 00:04:28,415
Some of you probably have guessed.

54
00:04:28,415 --> 00:04:33,304
We need to add the biases, just like we did it for

55
00:04:33,304 --> 00:04:37,827
our elementary solar panel data that we were

56
00:04:37,827 --> 00:04:40,894
using in the previous model.

57
00:04:40,894 --> 00:04:43,611
For each of the digits, 0 to 9,

58
00:04:43,611 --> 00:04:48,090
we have ten corresponding bias values that get added.

59
00:04:50,440 --> 00:04:54,470
So now we have ten classifiers,

60
00:04:54,470 --> 00:04:56,480
one corresponding to each digit here.

61
00:04:57,660 --> 00:05:02,680
Which emits a high value if the input digit belongs

62
00:05:02,680 --> 00:05:04,240
to that particular category.

63
00:05:04,240 --> 00:05:07,360
In other words, if the input digit is 0,

64
00:05:07,360 --> 00:05:10,970
this unit will activate high.

65
00:05:10,970 --> 00:05:14,470
If the input digit is 9, the last one will emit a high value,

66
00:05:14,470 --> 00:05:16,960
and the rest of it will be lower values.

67
00:05:18,770 --> 00:05:23,730
Now remember how our brain has output

68
00:05:23,730 --> 00:05:28,580
that have nonlinear responses to input features.

69
00:05:28,580 --> 00:05:32,131
Similarly, what we do in the case of neural networks, and

70
00:05:32,131 --> 00:05:35,690
you can all just see that happens in logistic regression.

71
00:05:35,690 --> 00:05:40,620
That you take some output from these units and

72
00:05:40,620 --> 00:05:44,641
these units, and you pass it through

73
00:05:44,641 --> 00:05:49,450
something called an activation function.

74
00:05:49,450 --> 00:05:54,881
In this case, we use a function called sigmoid,

75
00:05:54,881 --> 00:06:00,640
which maps any input within a range of 0 to 1.

76
00:06:00,640 --> 00:06:03,070
So for instance if you have a value of 2,

77
00:06:03,070 --> 00:06:06,470
it would emit a very high value.

78
00:06:06,470 --> 00:06:11,841
As opposed to a value of 0, which would emit a value of 0.5.

79
00:06:11,841 --> 00:06:15,833
And if you go into negative, if the input value's out of this

80
00:06:15,833 --> 00:06:19,433
accumulator, this unit are coming out to be very low,

81
00:06:19,433 --> 00:06:22,039
then you would get a output value of 0.

82
00:06:22,039 --> 00:06:25,390
Here you can see that only one cell,

83
00:06:25,390 --> 00:06:28,742
which corresponds to the digit 3,

84
00:06:28,742 --> 00:06:33,670
has high value, rest of them are relatively lower.

